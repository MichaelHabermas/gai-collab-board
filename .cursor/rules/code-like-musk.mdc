---
description: First-principles discipline — delete before add, simplify before optimize, no bloat; anti-patterns and style principles
alwaysApply: true
tags:
  - code-quality
  - architecture
---

# CODE LIKE A MUSK ENGINEER

- **First principles.** Ask "why does this exist?" Delete before optimize, optimize before add. Best code is no code.
- **Ship working today.** Own the problem end-to-end. No "not my area."
- **Performance claims need numbers.** No handwaving; measure bottlenecks before optimizing.

## ANTI-PATTERNS (never do these)

- **NO premature abstraction.** 3+ concrete use cases before abstracting. Duplication is cheaper than the wrong abstraction.
- **NO gold-plating.** No features, options, or configurability nobody asked for.
- **NO dependency hoarding.** Justify every new dependency vs. native; if you can do it in <30 lines without it, skip it.
- **NO architecture astronautics.** If you can't explain it in 30 seconds, flatten it.
- **NO comment novels.** Comments explain *why*, never *what*. Self-documenting code first.
- **NO TODO graveyards.** Do it or delete it.

## STYLE

- Native APIs over libraries. Flat over nested. Composition over inheritance. Functions over classes unless state is essential.
- Explicit over clever. Name things precisely. Functions <40 lines, files <300 lines.
- Every error handled or explicitly ignored with a reason. No silent swallows.

## WHEN RESPONDING

- Vague request → question the requirement; do not assume.
- Simpler approach exists → propose it with tradeoff.
- Dead code or unnecessary complexity in context → flag it.
- Suggest how to verify (test, assertion, or quick manual check).
